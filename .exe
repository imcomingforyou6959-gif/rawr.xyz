-- rawr.xyz owns u
-- onlyonestands :8)

local Bracket = (function()
    local success, lib = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/imcomingforyou6959-gif/rawr.xyz/refs/heads/main/UPI"))()
    end)
    return success and lib or nil
end)()
if not Bracket then return end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Stats = game:GetService("Stats")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")

local function getPing()
    return Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
end

local function hexToColor3(hex)
    hex = hex:gsub("#", "")
    local r = tonumber("0x" .. hex:sub(1,2)) / 255
    local g = tonumber("0x" .. hex:sub(3,4)) / 255
    local b = tonumber("0x" .. hex:sub(5,6)) / 255
    return Color3.new(r, g, b)
end

local function isDrawing(obj)
    return type(obj) == "table" and obj.Visible ~= nil
end

local function setVisible(obj, state)
    if isDrawing(obj) then
        pcall(function() obj.Visible = state end)
    end
end

local function setBox(box, size, pos, color, thickness)
    if isDrawing(box) then
        pcall(function()
            box.Size = size
            box.Position = pos
            box.Color = color
            box.Thickness = thickness or 1
            box.Visible = true
        end)
    end
end

local function setLine(line, from, to, color, thickness)
    if isDrawing(line) then
        pcall(function()
            line.From = from
            line.To = to
            line.Color = color
            line.Thickness = thickness or 1
            line.Visible = true
        end)
    end
end

local function setText(textObj, pos, color, text)
    if isDrawing(textObj) then
        pcall(function()
            textObj.Position = pos
            textObj.Color = color
            textObj.Text = text
            textObj.Visible = true
        end)
    end
end

local function setCircle(circle, pos, radius, color, filled, thickness)
    if isDrawing(circle) then
        pcall(function()
            circle.Position = pos
            circle.Radius = radius
            circle.Color = color
            circle.Filled = filled or false
            circle.Thickness = thickness or 1
            circle.Visible = true
        end)
    end
end

local MOUSE_BUTTONS = {
    MouseButton1 = true,
    MouseButton2 = true,
    MouseButton3 = true,
    RightButton = true,
    LeftButton = true,
    MiddleButton = true,
}

local Settings = {
    Aimbot = {
        Enabled = false,
        Key = "RightButton",
        KeyEnum = Enum.UserInputType.MouseButton2,
        Mode = "Crosshair",
        Smoothness = 0.3,
        HardLock = false,
        FOV = 150,
        ShowFOV = true,
        FOVFilled = false,
        FOVColor = Color3.fromRGB(255, 0, 0),
        TeamCheck = true,
        AimOnTeam = false,
        VisibleCheck = true,
        IgnoreVisibility = false,
        TargetPart = "Head",
        Prediction = 0.1,
        AutoPrediction = true,
        SilentAim = false,
        ShowTargetLine = false,
        StickyAim = false,
        StickyKey = "L",
        StickyKeyEnum = Enum.KeyCode.L,
        StickyTarget = nil,
        HitPartList = {
            "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso",
            "LeftHand", "RightHand", "LeftFoot", "RightFoot"
        },
        Orbit = {
            Enabled = false,
            Key = "O",
            KeyEnum = Enum.KeyCode.O,
            Speed = 5,
            Position = "Normal",
            OriginalCFrame = nil,
        },
        LockIndicator = {
            Enabled = false,
            Color = "#FF00FF",
            Pulse = false,
        },
    },
    Triggerbot = {
        Enabled = false,
        Delay = 0,
        RandomDelay = 0,
        Range = 10,
        OnKey = false,
        Key = "RightButton",
        KeyEnum = Enum.UserInputType.MouseButton2,
    },
    Visuals = {
        Enabled = false,
        MaxDistance = 1000,
        Box = true,
        BoxColor = "#FF0000",
        BoxThickness = 1,
        Box3D = false,
        Tracer = true,
        TracerColor = "#FFFFFF",
        TracerThickness = 1,
        TracerOrigin = "Crosshair",
        Health = true,
        HealthColor = "#00FF00",
        HealthGradient = true,
        HealthBackground = true,
        HealthPosition = "Left",
        HealthText = false,
        Name = true,
        NameColor = "#FFFFFF",
        TeamIcon = true,
        Distance = true,
        DistanceColor = "#FFFFFF",
        DistanceColorByDistance = true,
        DistanceUnit = "Studs",
        Weapon = false,
        WeaponColor = "#FFFF00",
        Skeleton = false,
        SkeletonColor = "#FFFFFF",
        SkeletonThickness = 1,
        CornerBox = false,
        CornerBoxColor = "#FF0000",
        CornerBoxThickness = 2,
        CornerBoxLengthFactor = 0.3,
        HeadDot = false,
        HeadDotColor = "#FF0000",
        HeadDotRadius = 3,
        HeadDotFilled = true,
        Radar = false,
        RadarSize = 150,
        RadarColor = "#FFFFFF",
        Chams = false,
        ChamsColor = "#00FF00",
        ViewAngle = false,
        ViewAngleColor = "#FFFF00",
        SnapLines = false,
        SnapLinesColor = "#FFFF00",
        SnapLinesThickness = 1,
        Rainbow = false,
        EnemyColor = "#FF0000",
        TeamColor = "#00FF00",
        DamageIndicators = false,
        Hitmarkers = false,
        HitEffect = false,
        HitEffectColor = "#FFFFFF",
    },
    Misc = {
        Walkspeed = { Enabled = false, Value = 16 },
        JumpPower = { Enabled = false, Value = 50 },
        CFrameSpeed = { Enabled = false, Value = 10 },
        Sit = false,
        ThirdPerson = false,
        BHop = false,
        NoClip = false,
        Freecam = false,
        FOV = 70,
    },
    UI = {
        ToggleKey = Enum.KeyCode.RightAlt,
        ToggleKeyName = "RightAlt",
    },
    Animation = {
        CurrentTrack = nil,
        AnimationId = "",
    },
    Players = {
        SelectedName = "",
        Spectating = false,
    }
}

local hue = 0
local function getRainbowColor()
    hue = (hue + 0.01) % 1
    return Color3.fromHSV(hue, 1, 1)
end

local function getHealthColor(health, maxHealth)
    if not Settings.Visuals.HealthGradient then
        return hexToColor3(Settings.Visuals.HealthColor)
    end
    local percent = health / maxHealth
    return Color3.new(1 - percent, percent, 0)
end

local function getDistanceColor(dist)
    if not Settings.Visuals.DistanceColorByDistance then
        return hexToColor3(Settings.Visuals.DistanceColor)
    end
    local percent = math.min(1, dist / Settings.Visuals.MaxDistance)
    return Color3.new(percent, 1 - percent, 0)
end

local function getPlayerColor(player)
    if player == LocalPlayer then
        return Color3.new(0, 1, 0)
    elseif player.Team == LocalPlayer.Team then
        return hexToColor3(Settings.Visuals.TeamColor)
    else
        return hexToColor3(Settings.Visuals.EnemyColor)
    end
end

local function notify(message, duration)
    duration = duration or 2
    StarterGui:SetCore("SendNotification", {
        Title = "rawr.xyz",
        Text = message,
        Duration = duration
    })
end

local Window = Bracket:Window({
    Name = "rawr.xyz",
    Position = UDim2.new(0.5, -250, 0.5, -200),
    Size = UDim2.new(0, 500, 0, 400),
    Color = Color3.fromRGB(255, 100, 100),
    Blur = false,
})
Window.Enabled = true

local AimbotTab = Window:Tab({ Name = "Aimbot" })
local VisualsTab = Window:Tab({ Name = "Visuals" })
local MiscTab = Window:Tab({ Name = "Misc" })
local PlayersTab = Window:Tab({ Name = "Players" })

local AimbotSection = AimbotTab:Section({ Name = "Aimbot", Side = "Left" })

AimbotSection:Toggle({
    Name = "Enable Aimbot",
    Flag = "AimbotEnabled",
    Value = false,
    Callback = function(v) Settings.Aimbot.Enabled = v end,
})

AimbotSection:Keybind({
    Name = "Aimbot Key",
    Flag = "AimbotKey",
    Value = Settings.Aimbot.Key,
    Mouse = true,
    Callback = function(key, pressed, toggle)
        if pressed and not toggle then
            Settings.Aimbot.Key = key
            local success, result = pcall(function()
                if MOUSE_BUTTONS[key] then
                    return Enum.UserInputType[key]
                else
                    return Enum.KeyCode[key]
                end
            end)
            if success then Settings.Aimbot.KeyEnum = result end
        end
    end,
})

AimbotSection:Toggle({
    Name = "Sticky Aim (lock onto target)",
    Flag = "StickyAim",
    Value = false,
    Callback = function(v) Settings.Aimbot.StickyAim = v end,
})

AimbotSection:Keybind({
    Name = "Sticky Key (toggle lock)",
    Flag = "StickyKey",
    Value = Settings.Aimbot.StickyKey,
    Mouse = true,
    Callback = function(key, pressed, toggle)
        if pressed and not toggle then
            Settings.Aimbot.StickyKey = key
            local success, result = pcall(function()
                if MOUSE_BUTTONS[key] then
                    return Enum.UserInputType[key]
                else
                    return Enum.KeyCode[key]
                end
            end)
            if success then Settings.Aimbot.StickyKeyEnum = result end
        end
    end,
})

AimbotSection:Toggle({
    Name = "Hard Lock (instant snap)",
    Flag = "HardLock",
    Value = false,
    Callback = function(v) Settings.Aimbot.HardLock = v end,
})

local OrbitSection = AimbotTab:Section({ Name = "Orbit Aimbot", Side = "Right" })
OrbitSection:Toggle({
    Name = "Enable Orbit",
    Flag = "OrbitEnabled",
    Value = false,
    Callback = function(v) Settings.Aimbot.Orbit.Enabled = v end,
})
OrbitSection:Keybind({
    Name = "Orbit Key (hold to orbit)",
    Flag = "OrbitKey",
    Value = Settings.Aimbot.Orbit.Key,
    Mouse = true,
    Callback = function(key, pressed, toggle)
        if pressed and not toggle then
            Settings.Aimbot.Orbit.Key = key
            local success, result = pcall(function()
                if MOUSE_BUTTONS[key] then
                    return Enum.UserInputType[key]
                else
                    return Enum.KeyCode[key]
                end
            end)
            if success then Settings.Aimbot.Orbit.KeyEnum = result end
        end
    end,
})
OrbitSection:Slider({
    Name = "Orbit Speed",
    Flag = "OrbitSpeed",
    Min = 1,
    Max = 20,
    Value = 5,
    Precise = 1,
    Callback = function(v) Settings.Aimbot.Orbit.Speed = v end,
})
OrbitSection:Dropdown({
    Name = "Orbit Position",
    Flag = "OrbitPosition",
    List = {
        { Name = "Head", Mode = "Button" },
        { Name = "Chest", Mode = "Button" },
        { Name = "Normal", Mode = "Button" },
        { Name = "Legs", Mode = "Button" },
    },
    Callback = function(selected)
        Settings.Aimbot.Orbit.Position = selected[1]
    end,
})

local LockIndicatorSection = AimbotTab:Section({ Name = "Lock Indicator", Side = "Right" })
LockIndicatorSection:Toggle({
    Name = "Enable Lock Indicator",
    Flag = "LockIndicator",
    Value = false,
    Callback = function(v) Settings.Aimbot.LockIndicator.Enabled = v end,
})
LockIndicatorSection:Colorpicker({
    Name = "Indicator Color",
    Flag = "LockColor",
    Value = {0.833, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Aimbot.LockIndicator.Color = "#" .. color:ToHex() end,
})
LockIndicatorSection:Toggle({
    Name = "Pulse Effect",
    Flag = "LockPulse",
    Value = false,
    Callback = function(v) Settings.Aimbot.LockIndicator.Pulse = v end,
})

AimbotSection:Dropdown({
    Name = "Aimbot Mode",
    Flag = "AimbotMode",
    List = {
        { Name = "Closest to Crosshair", Mode = "Button" },
        { Name = "Closest to Player", Mode = "Button" },
    },
    Callback = function(selected)
        Settings.Aimbot.Mode = (selected[1] == "Closest to Crosshair") and "Crosshair" or "Distance"
    end,
})

AimbotSection:Slider({
    Name = "FOV Size",
    Flag = "AimbotFOV",
    Min = 50,
    Max = 500,
    Value = Settings.Aimbot.FOV,
    Precise = 0,
    Callback = function(v) Settings.Aimbot.FOV = v end,
})

AimbotSection:Toggle({
    Name = "FOV Filled",
    Flag = "AimbotFOVFilled",
    Value = false,
    Callback = function(v) Settings.Aimbot.FOVFilled = v end,
})

AimbotSection:Toggle({
    Name = "Show Target Line",
    Flag = "AimbotTargetLine",
    Value = false,
    Callback = function(v) Settings.Aimbot.ShowTargetLine = v end,
})

AimbotSection:Colorpicker({
    Name = "FOV Color",
    Flag = "AimbotFOVColor",
    Value = {0, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Aimbot.FOVColor = color end,
})

AimbotSection:Slider({
    Name = "Smoothness",
    Flag = "AimbotSmoothness",
    Min = 10,
    Max = 80,
    Value = Settings.Aimbot.Smoothness * 100,
    Precise = 0,
    Callback = function(v) Settings.Aimbot.Smoothness = v / 100 end,
})

AimbotSection:Toggle({
    Name = "Silent Aim (experimental)",
    Flag = "AimbotSilent",
    Value = false,
    Callback = function(v) Settings.Aimbot.SilentAim = v end,
})

AimbotSection:Slider({
    Name = "Prediction (ms)",
    Flag = "AimbotPrediction",
    Min = 0,
    Max = 500,
    Value = Settings.Aimbot.Prediction * 1000,
    Precise = 0,
    Callback = function(v) Settings.Aimbot.Prediction = v / 1000 end,
})

AimbotSection:Toggle({
    Name = "Auto Prediction",
    Flag = "AimbotAutoPrediction",
    Value = Settings.Aimbot.AutoPrediction,
    Callback = function(v) Settings.Aimbot.AutoPrediction = v end,
})

AimbotSection:Toggle({
    Name = "Team Check",
    Flag = "AimbotTeamCheck",
    Value = Settings.Aimbot.TeamCheck,
    Callback = function(v) Settings.Aimbot.TeamCheck = v end,
})

AimbotSection:Toggle({
    Name = "Aim on Team (override)",
    Flag = "AimbotAimOnTeam",
    Value = Settings.Aimbot.AimOnTeam,
    Callback = function(v) Settings.Aimbot.AimOnTeam = v end,
})

AimbotSection:Toggle({
    Name = "Visible Check",
    Flag = "AimbotVisibleCheck",
    Value = Settings.Aimbot.VisibleCheck,
    Callback = function(v) Settings.Aimbot.VisibleCheck = v end,
})

AimbotSection:Toggle({
    Name = "Ignore Visibility",
    Flag = "AimbotIgnoreVis",
    Value = Settings.Aimbot.IgnoreVisibility,
    Callback = function(v) Settings.Aimbot.IgnoreVisibility = v end,
})

local partList = {}
for _, part in ipairs(Settings.Aimbot.HitPartList) do
    table.insert(partList, { Name = part, Mode = "Button" })
end

AimbotSection:Dropdown({
    Name = "Target Part",
    Flag = "AimbotTargetPart",
    List = partList,
    Callback = function(selected)
        if selected and #selected > 0 then
            Settings.Aimbot.TargetPart = selected[1]
        end
    end,
})

local TriggerSection = AimbotTab:Section({ Name = "Triggerbot", Side = "Right" })

TriggerSection:Toggle({
    Name = "Enable Triggerbot",
    Flag = "TriggerbotEnabled",
    Value = false,
    Callback = function(v) Settings.Triggerbot.Enabled = v end,
})

TriggerSection:Toggle({
    Name = "Trigger on Key (Hold Mode)",
    Flag = "TriggerbotOnKey",
    Value = false,
    Callback = function(v) Settings.Triggerbot.OnKey = v end,
})

TriggerSection:Keybind({
    Name = "Trigger Key",
    Flag = "TriggerbotKey",
    Value = Settings.Triggerbot.Key,
    Mouse = true,
    Callback = function(key, pressed, toggle)
        if pressed and not toggle then
            Settings.Triggerbot.Key = key
            local success, result = pcall(function()
                if MOUSE_BUTTONS[key] then
                    return Enum.UserInputType[key]
                else
                    return Enum.KeyCode[key]
                end
            end)
            if success then Settings.Triggerbot.KeyEnum = result end
        end
    end,
})

TriggerSection:Slider({
    Name = "Trigger Range (pixels)",
    Flag = "TriggerbotRange",
    Min = 5,
    Max = 50,
    Value = Settings.Triggerbot.Range,
    Precise = 0,
    Callback = function(v) Settings.Triggerbot.Range = v end,
})

TriggerSection:Slider({
    Name = "Base Delay (ms)",
    Flag = "TriggerbotDelay",
    Min = 0,
    Max = 500,
    Value = 0,
    Precise = 0,
    Callback = function(v) Settings.Triggerbot.Delay = v end,
})

TriggerSection:Slider({
    Name = "Random Delay Variation (ms)",
    Flag = "TriggerbotRandom",
    Min = 0,
    Max = 500,
    Value = 0,
    Precise = 0,
    Callback = function(v) Settings.Triggerbot.RandomDelay = v end,
})

local GeneralSection = VisualsTab:Section({ Name = "General", Side = "Left" })
GeneralSection:Toggle({
    Name = "Enable ESP",
    Flag = "VisualsEnabled",
    Value = false,
    Callback = function(v) Settings.Visuals.Enabled = v end,
})
GeneralSection:Slider({
    Name = "Max Distance",
    Flag = "VisualsMaxDistance",
    Min = 100,
    Max = 5000,
    Value = Settings.Visuals.MaxDistance,
    Precise = 0,
    Callback = function(v) Settings.Visuals.MaxDistance = v end,
})

local BoxSection = VisualsTab:Section({ Name = "Box", Side = "Left" })
BoxSection:Toggle({
    Name = "2D Box",
    Flag = "VisualsBox",
    Value = true,
    Callback = function(v) Settings.Visuals.Box = v end,
})
BoxSection:Colorpicker({
    Name = "Box Color",
    Flag = "VisualsBoxColor",
    Value = {0, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.BoxColor = "#" .. color:ToHex() end,
})
BoxSection:Slider({
    Name = "Box Thickness",
    Flag = "BoxThickness",
    Min = 1,
    Max = 5,
    Value = Settings.Visuals.BoxThickness,
    Precise = 0,
    Callback = function(v) Settings.Visuals.BoxThickness = v end,
})
BoxSection:Toggle({
    Name = "3D Box",
    Flag = "VisualsBox3D",
    Value = false,
    Callback = function(v) Settings.Visuals.Box3D = v end,
})

local TracerSection = VisualsTab:Section({ Name = "Tracer", Side = "Left" })
TracerSection:Toggle({
    Name = "Tracer",
    Flag = "VisualsTracer",
    Value = true,
    Callback = function(v) Settings.Visuals.Tracer = v end,
})
TracerSection:Colorpicker({
    Name = "Tracer Color",
    Flag = "VisualsTracerColor",
    Value = {0, 0, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.TracerColor = "#" .. color:ToHex() end,
})
TracerSection:Slider({
    Name = "Tracer Thickness",
    Flag = "TracerThickness",
    Min = 1,
    Max = 5,
    Value = Settings.Visuals.TracerThickness,
    Precise = 0,
    Callback = function(v) Settings.Visuals.TracerThickness = v end,
})
TracerSection:Dropdown({
    Name = "Tracer Origin",
    Flag = "TracerOrigin",
    List = {
        { Name = "Crosshair", Mode = "Button" },
        { Name = "Bottom Center", Mode = "Button" },
        { Name = "Top Center", Mode = "Button" },
        { Name = "Left Center", Mode = "Button" },
        { Name = "Right Center", Mode = "Button" },
    },
    Callback = function(selected)
        Settings.Visuals.TracerOrigin = selected[1]
    end,
})

local HealthSection = VisualsTab:Section({ Name = "Health", Side = "Right" })
HealthSection:Toggle({
    Name = "Health Bar",
    Flag = "VisualsHealth",
    Value = true,
    Callback = function(v) Settings.Visuals.Health = v end,
})
HealthSection:Toggle({
    Name = "Health Gradient",
    Flag = "HealthGradient",
    Value = true,
    Callback = function(v) Settings.Visuals.HealthGradient = v end,
})
HealthSection:Toggle({
    Name = "Health Background",
    Flag = "HealthBackground",
    Value = true,
    Callback = function(v) Settings.Visuals.HealthBackground = v end,
})
HealthSection:Colorpicker({
    Name = "Health Color",
    Flag = "VisualsHealthColor",
    Value = {0.333, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.HealthColor = "#" .. color:ToHex() end,
})
HealthSection:Dropdown({
    Name = "Health Bar Position",
    Flag = "HealthPosition",
    List = {
        { Name = "Left", Mode = "Button" },
        { Name = "Right", Mode = "Button" },
        { Name = "Top", Mode = "Button" },
        { Name = "Bottom", Mode = "Button" },
    },
    Callback = function(selected)
        Settings.Visuals.HealthPosition = selected[1]
    end,
})
HealthSection:Toggle({
    Name = "Health Text",
    Flag = "VisualsHealthText",
    Value = false,
    Callback = function(v) Settings.Visuals.HealthText = v end,
})

local NameSection = VisualsTab:Section({ Name = "Name & Distance", Side = "Right" })
NameSection:Toggle({
    Name = "Name",
    Flag = "VisualsName",
    Value = true,
    Callback = function(v) Settings.Visuals.Name = v end,
})
NameSection:Toggle({
    Name = "Team Icon",
    Flag = "TeamIcon",
    Value = true,
    Callback = function(v) Settings.Visuals.TeamIcon = v end,
})
NameSection:Colorpicker({
    Name = "Name Color",
    Flag = "VisualsNameColor",
    Value = {0, 0, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.NameColor = "#" .. color:ToHex() end,
})
NameSection:Toggle({
    Name = "Distance",
    Flag = "VisualsDistance",
    Value = true,
    Callback = function(v) Settings.Visuals.Distance = v end,
})
NameSection:Toggle({
    Name = "Distance Color by Distance",
    Flag = "DistanceColorByDistance",
    Value = true,
    Callback = function(v) Settings.Visuals.DistanceColorByDistance = v end,
})
NameSection:Colorpicker({
    Name = "Distance Color",
    Flag = "VisualsDistanceColor",
    Value = {0, 0, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.DistanceColor = "#" .. color:ToHex() end,
})
NameSection:Dropdown({
    Name = "Distance Unit",
    Flag = "DistanceUnit",
    List = {
        { Name = "Studs", Mode = "Button" },
        { Name = "Meters (approx)", Mode = "Button" },
        { Name = "Feet (approx)", Mode = "Button" },
    },
    Callback = function(selected)
        Settings.Visuals.DistanceUnit = selected[1]
    end,
})

local WeaponSection = VisualsTab:Section({ Name = "Weapon", Side = "Left" })
WeaponSection:Toggle({
    Name = "Show Weapon",
    Flag = "VisualsWeapon",
    Value = false,
    Callback = function(v) Settings.Visuals.Weapon = v end,
})
WeaponSection:Colorpicker({
    Name = "Weapon Color",
    Flag = "VisualsWeaponColor",
    Value = {0.166, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.WeaponColor = "#" .. color:ToHex() end,
})

local SkeletonSection = VisualsTab:Section({ Name = "Skeleton", Side = "Left" })
SkeletonSection:Toggle({
    Name = "Skeleton",
    Flag = "VisualsSkeleton",
    Value = false,
    Callback = function(v) Settings.Visuals.Skeleton = v end,
})
SkeletonSection:Colorpicker({
    Name = "Skeleton Color",
    Flag = "VisualsSkeletonColor",
    Value = {0, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.SkeletonColor = "#" .. color:ToHex() end,
})
SkeletonSection:Slider({
    Name = "Skeleton Thickness",
    Flag = "SkeletonThickness",
    Min = 1,
    Max = 5,
    Value = Settings.Visuals.SkeletonThickness,
    Precise = 0,
    Callback = function(v) Settings.Visuals.SkeletonThickness = v end,
})

local CornerSection = VisualsTab:Section({ Name = "Corner Box", Side = "Left" })
CornerSection:Toggle({
    Name = "Corner Box",
    Flag = "VisualsCornerBox",
    Value = false,
    Callback = function(v) Settings.Visuals.CornerBox = v end,
})
CornerSection:Colorpicker({
    Name = "Corner Box Color",
    Flag = "VisualsCornerBoxColor",
    Value = {0, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.CornerBoxColor = "#" .. color:ToHex() end,
})
CornerSection:Slider({
    Name = "Corner Thickness",
    Flag = "VisualsCornerThickness",
    Min = 1,
    Max = 5,
    Value = Settings.Visuals.CornerBoxThickness,
    Precise = 0,
    Callback = function(v) Settings.Visuals.CornerBoxThickness = v end,
})
CornerSection:Slider({
    Name = "Corner Length Factor",
    Flag = "VisualsCornerLengthFactor",
    Min = 0.1,
    Max = 0.5,
    Value = Settings.Visuals.CornerBoxLengthFactor,
    Precise = 2,
    Callback = function(v) Settings.Visuals.CornerBoxLengthFactor = v end,
})

local HeadDotSection = VisualsTab:Section({ Name = "Head Dot", Side = "Right" })
HeadDotSection:Toggle({
    Name = "Head Dot",
    Flag = "VisualsHeadDot",
    Value = false,
    Callback = function(v) Settings.Visuals.HeadDot = v end,
})
HeadDotSection:Colorpicker({
    Name = "Head Dot Color",
    Flag = "VisualsHeadDotColor",
    Value = {0, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.HeadDotColor = "#" .. color:ToHex() end,
})
HeadDotSection:Slider({
    Name = "Head Dot Radius",
    Flag = "VisualsHeadDotRadius",
    Min = 1,
    Max = 10,
    Value = Settings.Visuals.HeadDotRadius,
    Precise = 0,
    Callback = function(v) Settings.Visuals.HeadDotRadius = v end,
})
HeadDotSection:Toggle({
    Name = "Head Dot Filled",
    Flag = "VisualsHeadDotFilled",
    Value = true,
    Callback = function(v) Settings.Visuals.HeadDotFilled = v end,
})

local RadarSection = VisualsTab:Section({ Name = "Radar", Side = "Right" })
RadarSection:Toggle({
    Name = "Enable Radar",
    Flag = "VisualsRadar",
    Value = false,
    Callback = function(v) Settings.Visuals.Radar = v end,
})
RadarSection:Slider({
    Name = "Radar Size",
    Flag = "RadarSize",
    Min = 100,
    Max = 300,
    Value = Settings.Visuals.RadarSize,
    Precise = 0,
    Callback = function(v) Settings.Visuals.RadarSize = v end,
})
RadarSection:Colorpicker({
    Name = "Radar Dot Color",
    Flag = "RadarColor",
    Value = {0, 0, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.RadarColor = "#" .. color:ToHex() end,
})

local ChamsSection = VisualsTab:Section({ Name = "Chams", Side = "Right" })
ChamsSection:Toggle({
    Name = "Enable Chams",
    Flag = "VisualsChams",
    Value = false,
    Callback = function(v) Settings.Visuals.Chams = v end,
})
ChamsSection:Colorpicker({
    Name = "Chams Color",
    Flag = "ChamsColor",
    Value = {0.333, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.ChamsColor = "#" .. color:ToHex() end,
})

local ViewAngleSection = VisualsTab:Section({ Name = "View Angle", Side = "Right" })
ViewAngleSection:Toggle({
    Name = "Show View Angle",
    Flag = "VisualsViewAngle",
    Value = false,
    Callback = function(v) Settings.Visuals.ViewAngle = v end,
})
ViewAngleSection:Colorpicker({
    Name = "View Angle Color",
    Flag = "ViewAngleColor",
    Value = {0.166, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.ViewAngleColor = "#" .. color:ToHex() end,
})

local SnapLinesSection = VisualsTab:Section({ Name = "Snap Lines", Side = "Left" })
SnapLinesSection:Toggle({
    Name = "Enable Snap Lines",
    Flag = "SnapLines",
    Value = false,
    Callback = function(v) Settings.Visuals.SnapLines = v end,
})
SnapLinesSection:Colorpicker({
    Name = "Snap Lines Color",
    Flag = "SnapLinesColor",
    Value = {0.166, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.SnapLinesColor = "#" .. color:ToHex() end,
})
SnapLinesSection:Slider({
    Name = "Snap Lines Thickness",
    Flag = "SnapLinesThickness",
    Min = 1,
    Max = 5,
    Value = Settings.Visuals.SnapLinesThickness,
    Precise = 0,
    Callback = function(v) Settings.Visuals.SnapLinesThickness = v end,
})

local RainbowSection = VisualsTab:Section({ Name = "Rainbow", Side = "Left" })
RainbowSection:Toggle({
    Name = "Rainbow ESP",
    Flag = "VisualsRainbow",
    Value = false,
    Callback = function(v) Settings.Visuals.Rainbow = v end,
})

local PlayerColorsSection = VisualsTab:Section({ Name = "Player Colors", Side = "Left" })
PlayerColorsSection:Colorpicker({
    Name = "Enemy Color",
    Flag = "EnemyColor",
    Value = {0, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.EnemyColor = "#" .. color:ToHex() end,
})
PlayerColorsSection:Colorpicker({
    Name = "Team Color",
    Flag = "TeamColor",
    Value = {0.333, 1, 1, 0, false},
    Callback = function(tbl, color) Settings.Visuals.TeamColor = "#" .. color:ToHex() end,
})

local DamageSection = VisualsTab:Section({ Name = "Damage Indicators", Side = "Left" })
DamageSection:Toggle({
    Name = "Enable Damage Indicators",
    Flag = "DamageIndicators",
    Value = false,
    Callback = function(v) Settings.Visuals.DamageIndicators = v end,
})
DamageSection:Toggle({
    Name = "Hitmarkers",
    Flag = "Hitmarkers",
    Value = false,
    Callback = function(v) Settings.Visuals.Hitmarkers = v end,
})
DamageSection:Toggle({
    Name = "Hit Effect (flash on target)",
    Flag = "HitEffect",
    Value = false,
    Callback = function(v) Settings.Visuals.HitEffect = v end,
})
DamageSection:Colorpicker({
    Name = "Hit Effect Color",
    Flag = "HitEffectColor",
    Value = {0, 0, 0, 0, false},
    Callback = function(tbl, color) Settings.Visuals.HitEffectColor = "#" .. color:ToHex() end,
})

local MiscSection = MiscTab:Section({ Name = "Movement", Side = "Left" })

MiscSection:Toggle({
    Name = "Walkspeed",
    Flag = "WalkspeedEnabled",
    Value = false,
    Callback = function(v) Settings.Misc.Walkspeed.Enabled = v end,
})
MiscSection:Slider({
    Name = "Walkspeed Value",
    Flag = "Walkspeed",
    Min = 16,
    Max = 200,
    Value = 16,
    Precise = 0,
    Callback = function(v) Settings.Misc.Walkspeed.Value = v end,
})

MiscSection:Toggle({
    Name = "Jump Power",
    Flag = "JumpEnabled",
    Value = false,
    Callback = function(v) Settings.Misc.JumpPower.Enabled = v end,
})
MiscSection:Slider({
    Name = "Jump Power Value",
    Flag = "JumpPower",
    Min = 50,
    Max = 200,
    Value = 50,
    Precise = 0,
    Callback = function(v) Settings.Misc.JumpPower.Value = v end,
})

MiscSection:Toggle({
    Name = "CFrame Speed",
    Flag = "CFrameSpeedEnabled",
    Value = false,
    Callback = function(v) Settings.Misc.CFrameSpeed.Enabled = v end,
})
MiscSection:Slider({
    Name = "CFrame Speed Value",
    Flag = "CFrameSpeed",
    Min = 1,
    Max = 100,
    Value = 10,
    Precise = 0,
    Callback = function(v) Settings.Misc.CFrameSpeed.Value = v end,
})

MiscSection:Toggle({
    Name = "Force Sit",
    Flag = "ForceSit",
    Value = false,
    Callback = function(v) Settings.Misc.Sit = v end,
})

MiscSection:Toggle({
    Name = "Third Person Unlocker",
    Flag = "ThirdPerson",
    Value = false,
    Callback = function(v)
        Settings.Misc.ThirdPerson = v
        if v then
            LocalPlayer.CameraMode = Enum.CameraMode.Classic
        else
            LocalPlayer.CameraMode = Enum.CameraMode.LockFirstPerson
        end
    end,
})

MiscSection:Toggle({
    Name = "BHop (Auto Bunny Hop)",
    Flag = "BHop",
    Value = false,
    Callback = function(v) Settings.Misc.BHop = v end,
})

MiscSection:Toggle({
    Name = "NoClip",
    Flag = "NoClip",
    Value = false,
    Callback = function(v) Settings.Misc.NoClip = v end,
})

MiscSection:Toggle({
    Name = "Freecam",
    Flag = "Freecam",
    Value = false,
    Callback = function(v)
        Settings.Misc.Freecam = v
        if not v then
            Camera.CameraSubject = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") or LocalPlayer
        end
    end,
})

MiscSection:Slider({
    Name = "Field of View",
    Flag = "FOV",
    Min = 20,
    Max = 120,
    Value = 70,
    Precise = 0,
    Callback = function(v) Settings.Misc.FOV = v end,
})

local ServerSection = MiscTab:Section({ Name = "Server", Side = "Right" })

ServerSection:Button({
    Name = "Rejoin Same Server",
    Callback = function()
        pcall(function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
        end)
    end,
})

ServerSection:Button({
    Name = "Server Hop",
    Callback = function()
        pcall(function()
            local cursor = ""
            local found = false
            for i = 1, 5 do
                local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?limit=100" .. (cursor ~= "" and "&cursor=" .. cursor or "")
                local success, response = pcall(function()
                    return HttpService:JSONDecode(game:HttpGet(url))
                end)
                if success and response and response.data then
                    for _, server in ipairs(response.data) do
                        if server.playing < server.maxPlayers and server.id ~= game.JobId then
                            TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, LocalPlayer)
                            found = true
                            break
                        end
                    end
                    if found then break end
                    cursor = response.nextPageCursor or ""
                else
                    break
                end
            end
        end)
    end,
})

ServerSection:Button({
    Name = "Copy Place ID",
    Callback = function()
        if setclipboard then setclipboard(tostring(game.PlaceId)) end
    end,
})

ServerSection:Button({
    Name = "Copy Job ID",
    Callback = function()
        if setclipboard then setclipboard(game.JobId) end
    end,
})

ServerSection:Button({
    Name = "Copy Join Script",
    Callback = function()
        if setclipboard then
            setclipboard('game:GetService("TeleportService"):Teleport(' .. game.PlaceId .. ', game:GetService("Players").LocalPlayer)')
        end
    end,
})

local ServerInfoSection = MiscTab:Section({ Name = "Server Info", Side = "Right" })

local serverRegionLabel = ServerInfoSection:Label({ Name = "Region: Unknown" })
local playerCountLabel = ServerInfoSection:Label({ Name = "Players: 0/0" })
local uptimeLabel = ServerInfoSection:Label({ Name = "Uptime: 0s" })

local function updateLabel(label, text)
    if label and label.Instance then
        label.Instance.Text = text
    elseif label and label.Text then
        label.Text = text
    end
end

task.spawn(function()
    while true do
        task.wait(1)
        pcall(function()
            local ping = getPing() * 1000
            local region
            if ping < 50 then
                region = "Local"
            elseif ping < 100 then
                region = "US West"
            elseif ping < 150 then
                region = "US East"
            elseif ping < 200 then
                region = "Europe"
            elseif ping < 300 then
                region = "Asia"
            else
                region = "Other"
            end
            updateLabel(serverRegionLabel, "Region: " .. region)
            local playerCount = #Players:GetPlayers()
            local maxPlayers = Players.MaxPlayers or 50
            updateLabel(playerCountLabel, "Players: " .. playerCount .. "/" .. maxPlayers)
            local uptime = workspace.DistributedGameTime
            updateLabel(uptimeLabel, "Uptime: " .. math.floor(uptime) .. "s")
        end)
    end
end)

local UISection = MiscTab:Section({ Name = "UI Settings", Side = "Right" })

UISection:Keybind({
    Name = "Toggle UI Key",
    Flag = "UIToggleKey",
    Value = Settings.UI.ToggleKeyName,
    Mouse = true,
    Callback = function(key, pressed, toggle)
        if pressed and not toggle then
            Settings.UI.ToggleKeyName = key
            local success, result = pcall(function()
                if MOUSE_BUTTONS[key] then
                    return Enum.UserInputType[key]
                else
                    return Enum.KeyCode[key]
                end
            end)
            if success then Settings.UI.ToggleKey = result end
        end
    end,
})

UISection:Button({
    Name = "Unload UI",
    Callback = function()
        pcall(function()
            if FOVCircle and FOVCircle.Remove then FOVCircle:Remove() end
            if TargetLine and TargetLine.Remove then TargetLine:Remove() end
            if RadarCircle and RadarCircle.Remove then RadarCircle:Remove() end
            for player, ui in pairs(ESPCache) do
                if ui then
                    if ui.Box and ui.Box.Remove then ui.Box:Remove() end
                    if ui.Tracer and ui.Tracer.Remove then ui.Tracer:Remove() end
                    if ui.Health and ui.Health.Remove then ui.Health:Remove() end
                    if ui.HealthBackground and ui.HealthBackground.Remove then ui.HealthBackground:Remove() end
                    if ui.Name and ui.Name.Remove then ui.Name:Remove() end
                    if ui.HeadDot and ui.HeadDot.Remove then ui.HeadDot:Remove() end
                    if ui.Weapon and ui.Weapon.Remove then ui.Weapon:Remove() end
                    if ui.HealthText and ui.HealthText.Remove then ui.HealthText:Remove() end
                    if ui.ViewAngle and ui.ViewAngle.Remove then ui.ViewAngle:Remove() end
                    if ui.SnapLine and ui.SnapLine.Remove then ui.SnapLine:Remove() end
                    if ui.RadarDot and ui.RadarDot.Remove then ui.RadarDot:Remove() end
                    if ui.Chams and ui.Chams.Remove then ui.Chams:Remove() end
                    if ui.Skeleton then
                        for _, line in pairs(ui.Skeleton) do if line and line.Remove then line:Remove() end end
                    end
                    if ui.Box3D then
                        for _, line in pairs(ui.Box3D) do if line and line.Remove then line:Remove() end end
                    end
                    if ui.CornerLines then
                        for i = 1, 8 do if ui.CornerLines[i] and ui.CornerLines[i].Remove then ui.CornerLines[i]:Remove() end end
                    end
                end
            end
            if Settings.Animation.CurrentTrack and Settings.Animation.CurrentTrack.Stop then
                Settings.Animation.CurrentTrack:Stop()
            end
            if Window and Window.Instance then Window.Instance:Destroy() end
            if Bracket and Bracket.Screen then Bracket.Screen:Destroy() end
        end)
    end,
})

local AnimSection = MiscTab:Section({ Name = "Animation Player", Side = "Left" })

AnimSection:Textbox({
    Name = "Animation ID (rbxassetid://...)",
    Flag = "AnimID",
    Placeholder = "Enter ID e.g. 507767613",
    Callback = function(value)
        if tonumber(value) then
            Settings.Animation.AnimationId = "rbxassetid://" .. value
        elseif string.find(value, "rbxassetid://") then
            Settings.Animation.AnimationId = value
        else
            Settings.Animation.AnimationId = value
        end
    end,
})

AnimSection:Button({
    Name = "Play Animation",
    Callback = function()
        local character = LocalPlayer.Character
        if not character then return end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        local animId = Settings.Animation.AnimationId
        if animId == "" then return end
        if not string.find(animId, "rbxassetid://") then
            animId = "rbxassetid://" .. animId
        end
        if Settings.Animation.CurrentTrack and Settings.Animation.CurrentTrack.PlaybackState ~= Enum.PlaybackState.Stopped then
            Settings.Animation.CurrentTrack:Stop()
        end
        local animator = humanoid.Animator
        if not animator then return end
        local success, track = pcall(function()
            local animation = Instance.new("Animation")
            animation.AnimationId = animId
            return animator:LoadAnimation(animation)
        end)
        if success and track then
            track:Play()
            Settings.Animation.CurrentTrack = track
        end
    end,
})

AnimSection:Button({
    Name = "Stop",
    Callback = function()
        if Settings.Animation.CurrentTrack and Settings.Animation.CurrentTrack.PlaybackState ~= Enum.PlaybackState.Stopped then
            Settings.Animation.CurrentTrack:Stop()
            Settings.Animation.CurrentTrack = nil
        end
    end,
})

if LocalPlayer then
    LocalPlayer.CharacterAdded:Connect(function()
        Settings.Animation.CurrentTrack = nil
    end)
end

local PlayerSection = PlayersTab:Section({ Name = "Player Actions", Side = "Left" })

PlayerSection:Textbox({
    Name = "Player Name",
    Flag = "PlayerNameInput",
    Placeholder = "Enter username or display name",
    Callback = function(v)
        Settings.Players.SelectedName = v
    end,
})

local function findPlayerByName(name)
    if name == "" then return nil end
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Name:lower() == name:lower() or (p.DisplayName and p.DisplayName:lower() == name:lower()) then
            return p
        end
    end
    return nil
end

local spectating = false
local function stopSpectating()
    if spectating then
        Camera.CameraSubject = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") or LocalPlayer
        spectating = false
        Settings.Players.Spectating = false
    end
end

PlayerSection:Toggle({
    Name = "Spectate Player",
    Flag = "SpectateToggle",
    Value = false,
    Callback = function(v)
        task.spawn(function()
            if v then
                local target = findPlayerByName(Settings.Players.SelectedName)
                if target and target.Character and target.Character:FindFirstChildOfClass("Humanoid") then
                    Camera.CameraSubject = target.Character:FindFirstChildOfClass("Humanoid")
                    spectating = true
                    Settings.Players.Spectating = true
                else
                    v = false
                end
            else
                stopSpectating()
            end
        end)
    end,
})

PlayerSection:Button({
    Name = "Teleport to Player",
    Callback = function()
        local target = findPlayerByName(Settings.Players.SelectedName)
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.CFrame = target.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 3)
            end
        end
    end,
})

PlayerSection:Button({
    Name = "Copy Username",
    Callback = function()
        local target = findPlayerByName(Settings.Players.SelectedName)
        if target and setclipboard then
            setclipboard(target.Name)
        end
    end,
})

PlayerSection:Button({
    Name = "Copy User ID",
    Callback = function()
        local target = findPlayerByName(Settings.Players.SelectedName)
        if target and setclipboard then
            setclipboard(tostring(target.UserId))
        end
    end,
})

PlayerSection:Button({
    Name = "Open Profile (Browser)",
    Callback = function()
        local target = findPlayerByName(Settings.Players.SelectedName)
        if target then
            local url = "https://www.roblox.com/users/" .. target.UserId .. "/profile"
            if syn and syn.request then
                syn.request({Url = url, Method = "GET"})
            else
                setclipboard(url)
            end
        end
    end,
})

PlayerSection:Button({
    Name = "View Tools",
    Callback = function()
        local target = findPlayerByName(Settings.Players.SelectedName)
        if target and target.Character then
            local tools = {}
            for _, child in ipairs(target.Character:GetChildren()) do
                if child:IsA("Tool") then
                    table.insert(tools, child.Name)
                end
            end
            if #tools > 0 then
                print(target.Name .. "'s tools: " .. table.concat(tools, ", "))
            else
                print(target.Name .. " has no tools equipped.")
            end
        end
    end,
})

Players.PlayerRemoving:Connect(function(p)
    if p == findPlayerByName(Settings.Players.SelectedName) then
        stopSpectating()
    end
end)

if LocalPlayer.Character then
    LocalPlayer.Character:FindFirstChildOfClass("Humanoid").Died:Connect(function()
        if spectating then stopSpectating() end
    end)
end

local FOVCircle = Drawing.new("Circle")
if isDrawing(FOVCircle) then
    FOVCircle.Visible = false
    FOVCircle.Thickness = 2
    FOVCircle.NumSides = 60
    FOVCircle.Filled = false
end

local TargetLine = Drawing.new("Line")
if isDrawing(TargetLine) then
    TargetLine.Visible = false
    TargetLine.Thickness = 1
    TargetLine.Color = Color3.new(1,1,0)
end

local RadarCircle = Drawing.new("Circle")
if isDrawing(RadarCircle) then
    RadarCircle.Thickness = 1
    RadarCircle.NumSides = 60
    RadarCircle.Filled = false
    RadarCircle.Color = Color3.new(1,1,1)
    RadarCircle.Visible = false
end

local function IsEnemy(player)
    if player == LocalPlayer then return false end
    if Settings.Aimbot.AimOnTeam then return true end
    if Settings.Aimbot.TeamCheck then
        if player.TeamColor == LocalPlayer.TeamColor or (player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team) then
            return false
        end
    end
    return true
end

local function IsVisible(targetPart)
    if Settings.Aimbot.IgnoreVisibility then return true end
    local origin = Camera.CFrame.Position
    local direction = targetPart.Position - origin
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    local result = workspace:Raycast(origin, direction, rayParams)
    return not result or result.Instance:IsDescendantOf(targetPart.Parent)
end

local function GetTargetPart(character)
    if not character then return nil end
    local part = character:FindFirstChild(Settings.Aimbot.TargetPart)
    if not part then
        part = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
    end
    return part
end

local function GetPredictedPosition(part)
    if not part then return nil end
    local pred = Settings.Aimbot.Prediction
    if Settings.Aimbot.AutoPrediction then
        local speed = part.Velocity.Magnitude
        if speed > 5 and speed < 200 then
            pred = pred * (speed / 50) + getPing()
        else
            pred = pred + getPing()
        end
    end
    return part.Position + part.Velocity * pred
end

local function GetClosestTarget(ignoreCurrent)
    local closest = nil
    local closestDist = (Settings.Aimbot.Mode == "Crosshair") and Settings.Aimbot.FOV or math.huge
    local screenCenter = Camera.ViewportSize / 2
    for _, player in pairs(Players:GetPlayers()) do
        if not IsEnemy(player) then continue end
        if ignoreCurrent and player == Settings.Aimbot.StickyTarget then continue end
        if not player.Character then continue end
        local targetPart = GetTargetPart(player.Character)
        if not targetPart then continue end
        if Settings.Aimbot.VisibleCheck and not IsVisible(targetPart) then
            continue
        end
        local targetPos = GetPredictedPosition(targetPart)
        if not targetPos then continue end
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
        if not onScreen or screenPos.Z <= 0 then continue end
        if Settings.Aimbot.Mode == "Crosshair" then
            local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
            if dist > Settings.Aimbot.FOV then continue end
            if dist < closestDist then
                closestDist = dist
                closest = player
            end
        else
            local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if myPos then
                local dist = (targetPart.Position - myPos.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

local aimbotKeyPressed = false
local function updateKeyState()
    local key = Settings.Aimbot.KeyEnum
    if not key then return end
    if typeof(key) == "EnumItem" then
        if key.Name:find("Button") then
            aimbotKeyPressed = UserInputService:IsMouseButtonPressed(key)
        else
            aimbotKeyPressed = UserInputService:IsKeyDown(key)
        end
    else
        aimbotKeyPressed = false
    end
end

local triggerKeyPressed = false
local function updateTriggerKeyState()
    local key = Settings.Triggerbot.KeyEnum
    if not key then return end
    if typeof(key) == "EnumItem" then
        if key.Name:find("Button") then
            triggerKeyPressed = UserInputService:IsMouseButtonPressed(key)
        else
            triggerKeyPressed = UserInputService:IsKeyDown(key)
        end
    else
        triggerKeyPressed = false
    end
end

local orbitKeyPressed = false
local function updateOrbitKeyState()
    local key = Settings.Aimbot.Orbit.KeyEnum
    if not key then return end
    if typeof(key) == "EnumItem" then
        if key.Name:find("Button") then
            orbitKeyPressed = UserInputService:IsMouseButtonPressed(key)
        else
            orbitKeyPressed = UserInputService:IsKeyDown(key)
        end
    else
        orbitKeyPressed = false
    end
end

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if Settings.Aimbot.StickyAim and input.KeyCode == Settings.Aimbot.StickyKeyEnum then
        if Settings.Aimbot.StickyTarget then
            Settings.Aimbot.StickyTarget = nil
            notify("Sticky aim unlocked", 1)
        else
            local target = GetClosestTarget(false)
            if target then
                Settings.Aimbot.StickyTarget = target
                notify("Sticky aim locked on " .. target.Name, 2)
            else
                notify("No target found", 1)
            end
        end
    end
end)

local lastTriggerTime = 0
local function doTrigger()
    if not Settings.Triggerbot.Enabled then return end
    if Settings.Triggerbot.OnKey and not triggerKeyPressed then return end
    local targetPart = nil
    local targetPlayer = nil
    if Settings.Aimbot.StickyAim and Settings.Aimbot.StickyTarget then
        targetPlayer = Settings.Aimbot.StickyTarget
        if targetPlayer and targetPlayer.Character then
            targetPart = GetTargetPart(targetPlayer.Character)
        end
    else
        targetPlayer = GetClosestTarget(false)
        if targetPlayer then
            targetPart = GetTargetPart(targetPlayer.Character)
        end
    end
    if targetPart then
        local targetPos = GetPredictedPosition(targetPart)
        if not targetPos then return end
        local screenPos = Camera:WorldToViewportPoint(targetPos)
        local screenCenter = Camera.ViewportSize / 2
        local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if dist < Settings.Triggerbot.Range then
            local now = tick()
            local delay = Settings.Triggerbot.Delay / 1000
            if Settings.Triggerbot.RandomDelay > 0 then
                delay = delay + (math.random() * Settings.Triggerbot.RandomDelay / 1000)
            end
            if now - lastTriggerTime > delay then
                lastTriggerTime = now
                if mouse1press and mouse1release then
                    mouse1press()
                    task.wait(0.02)
                    mouse1release()
                end
            end
        end
    end
end

local function updateMovement()
    if LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then
            if Settings.Misc.Walkspeed.Enabled then
                hum.WalkSpeed = Settings.Misc.Walkspeed.Value
            end
            if Settings.Misc.JumpPower.Enabled then
                hum.JumpPower = Settings.Misc.JumpPower.Value
            end
        end
    end
end

local function updateCFrameSpeed()
    if not Settings.Misc.CFrameSpeed.Enabled then return end
    if not LocalPlayer.Character then return end
    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
        hrp.CFrame = hrp.CFrame + Camera.CFrame.LookVector * Settings.Misc.CFrameSpeed.Value
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
        hrp.CFrame = hrp.CFrame - Camera.CFrame.LookVector * Settings.Misc.CFrameSpeed.Value
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
        hrp.CFrame = hrp.CFrame - Camera.CFrame.RightVector * Settings.Misc.CFrameSpeed.Value
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
        hrp.CFrame = hrp.CFrame + Camera.CFrame.RightVector * Settings.Misc.CFrameSpeed.Value
    end
end

local function updateSit()
    if Settings.Misc.Sit and LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then hum.Sit = true end
    end
end

local bhopLastJump = 0
local function updateBHop()
    if not Settings.Misc.BHop then return end
    if not LocalPlayer.Character then return end
    local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    if hum.FloorMaterial == Enum.Material.Air then return end
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
        local now = tick()
        if now - bhopLastJump > 0.2 then
            hum.Jump = true
            bhopLastJump = now
        end
    end
end

local noclipConnection
local function updateNoClip()
    if Settings.Misc.NoClip then
        if not noclipConnection then
            noclipConnection = RunService.Stepped:Connect(function()
                if not LocalPlayer.Character then return end
                for _, v in pairs(LocalPlayer.Character:GetDescendants()) do
                    if v:IsA("BasePart") and v.CanCollide then
                        v.CanCollide = false
                    end
                end
            end)
        end
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
            if LocalPlayer.Character then
                for _, v in pairs(LocalPlayer.Character:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.CanCollide = true
                    end
                end
            end
        end
    end
end

local freecamObject = nil
local freecamConnection = nil
local function updateFreecam()
    if Settings.Misc.Freecam then
        if not freecamObject then
            freecamObject = Instance.new("Part")
            freecamObject.Name = "FreecamPart"
            freecamObject.Anchored = true
            freecamObject.CanCollide = false
            freecamObject.Transparency = 1
            freecamObject.Size = Vector3.new(1,1,1)
            freecamObject.Parent = workspace
            Camera.CameraSubject = freecamObject
            freecamConnection = RunService.RenderStepped:Connect(function()
                local move = Vector3.new()
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    move = move + Camera.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    move = move - Camera.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    move = move - Camera.CFrame.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    move = move + Camera.CFrame.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.E) then
                    move = move + Vector3.new(0,1,0)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.Q) then
                    move = move - Vector3.new(0,1,0)
                end
                freecamObject.CFrame = freecamObject.CFrame + move * 0.5
                Camera.CFrame = CFrame.new(freecamObject.Position, freecamObject.Position + Camera.CFrame.LookVector * 10)
            end)
        end
    else
        if freecamConnection then
            freecamConnection:Disconnect()
            freecamConnection = nil
        end
        if freecamObject then
            freecamObject:Destroy()
            freecamObject = nil
        end
        Camera.CameraSubject = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") or LocalPlayer
    end
end

local orbitAngle = 0
local function updateOrbit()
    if not Settings.Aimbot.Orbit.Enabled then return end
    if not Settings.Aimbot.StickyTarget then return end
    local target = Settings.Aimbot.StickyTarget
    if not target or not target.Character then return end
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    if orbitKeyPressed then
        if not Settings.Aimbot.Orbit.OriginalCFrame then
            Settings.Aimbot.Orbit.OriginalCFrame = myRoot.CFrame
        end
        local targetPos
        local orbitPos = Settings.Aimbot.Orbit.Position
        if orbitPos == "Head" then
            local head = target.Character:FindFirstChild("Head")
            targetPos = head and head.Position or target.Character.HumanoidRootPart.Position
        elseif orbitPos == "Chest" then
            local chest = target.Character:FindFirstChild("UpperTorso") or target.Character:FindFirstChild("Torso")
            targetPos = chest and chest.Position or target.Character.HumanoidRootPart.Position
        elseif orbitPos == "Legs" then
            local leg = target.Character:FindFirstChild("LeftFoot") or target.Character:FindFirstChild("RightFoot") or target.Character:FindFirstChild("LowerTorso")
            targetPos = leg and leg.Position or target.Character.HumanoidRootPart.Position
        else
            targetPos = target.Character.HumanoidRootPart.Position
        end
        local radius = 5
        local speed = Settings.Aimbot.Orbit.Speed
        orbitAngle = orbitAngle + math.rad(speed)
        local offset = Vector3.new(math.cos(orbitAngle) * radius, 0, math.sin(orbitAngle) * radius)
        local newPos = targetPos + offset
        myRoot.CFrame = CFrame.new(newPos) * CFrame.Angles(0, orbitAngle + math.pi/2, 0)
        local camPos = Camera.CFrame.Position
        local targetCF = CFrame.lookAt(camPos, targetPos)
        Camera.CFrame = targetCF
    else
        if Settings.Aimbot.Orbit.OriginalCFrame then
            myRoot.CFrame = Settings.Aimbot.Orbit.OriginalCFrame
            Settings.Aimbot.Orbit.OriginalCFrame = nil
            orbitAngle = 0
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if (input.KeyCode == Settings.UI.ToggleKey) or (input.UserInputType == Settings.UI.ToggleKey) then
        Window.Enabled = not Window.Enabled
    end
end)

RunService.RenderStepped:Connect(function()
    if Settings.Aimbot.ShowFOV and Settings.Aimbot.Enabled and isDrawing(FOVCircle) then
        FOVCircle.Visible = true
        FOVCircle.Radius = Settings.Aimbot.FOV
        FOVCircle.Color = Settings.Aimbot.FOVColor
        FOVCircle.Filled = Settings.Aimbot.FOVFilled
        FOVCircle.Position = Camera.ViewportSize / 2
    else
        setVisible(FOVCircle, false)
    end
    updateKeyState()
    updateTriggerKeyState()
    updateOrbitKeyState()
    if Settings.Aimbot.StickyAim and Settings.Aimbot.StickyTarget then
        local target = Settings.Aimbot.StickyTarget
        if not target or not target.Parent or not target.Character or not target.Character:FindFirstChildOfClass("Humanoid") or target.Character.Humanoid.Health <= 0 or not IsEnemy(target) then
            Settings.Aimbot.StickyTarget = nil
        end
    end
    local targetPart = nil
    if Settings.Aimbot.Enabled and aimbotKeyPressed then
        if Settings.Aimbot.StickyAim and Settings.Aimbot.StickyTarget then
            local target = Settings.Aimbot.StickyTarget
            if target and target.Character then
                targetPart = GetTargetPart(target.Character)
            end
        else
            local targetPlayer = GetClosestTarget(false)
            if targetPlayer then
                targetPart = GetTargetPart(targetPlayer.Character)
            end
        end
    end
    if Settings.Aimbot.ShowTargetLine and targetPart and isDrawing(TargetLine) then
        local targetPos = GetPredictedPosition(targetPart)
        if targetPos then
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
            if onScreen then
                TargetLine.From = Camera.ViewportSize / 2
                TargetLine.To = Vector2.new(screenPos.X, screenPos.Y)
                TargetLine.Visible = true
            else
                TargetLine.Visible = false
            end
        else
            TargetLine.Visible = false
        end
    else
        setVisible(TargetLine, false)
    end
    if not spectating then
        if not orbitKeyPressed or not Settings.Aimbot.Orbit.Enabled then
            if targetPart and not Settings.Aimbot.SilentAim then
                local targetPos = GetPredictedPosition(targetPart)
                if targetPos then
                    local camPos = Camera.CFrame.Position
                    local targetCF = CFrame.lookAt(camPos, targetPos)
                    local smooth = Settings.Aimbot.HardLock and 1 or Settings.Aimbot.Smoothness
                    Camera.CFrame = Camera.CFrame:Lerp(targetCF, smooth)
                end
            end
        end
    end
    doTrigger()
    updateMovement()
    updateCFrameSpeed()
    updateSit()
    updateBHop()
    updateNoClip()
    updateFreecam()
    updateOrbit()
    Camera.FieldOfView = Settings.Misc.FOV
end)

local ESPCache = {}
local DamageIndicators = {}
local Hitmarkers = {}
local HitEffects = {}

local function hideESP(ui)
    if not ui or type(ui) ~= "table" then return end
    setVisible(ui.Box, false)
    setVisible(ui.Tracer, false)
    setVisible(ui.Health, false)
    setVisible(ui.HealthBackground, false)
    setVisible(ui.Name, false)
    setVisible(ui.HeadDot, false)
    setVisible(ui.Weapon, false)
    setVisible(ui.HealthText, false)
    setVisible(ui.ViewAngle, false)
    setVisible(ui.SnapLine, false)
    setVisible(ui.RadarDot, false)
    if ui.Chams and ui.Chams.Remove then
        pcall(ui.Chams.Remove, ui.Chams)
    end
    if ui.Skeleton then
        for _, line in pairs(ui.Skeleton) do setVisible(line, false) end
    end
    if ui.Box3D then
        for _, line in pairs(ui.Box3D) do setVisible(line, false) end
    end
    if ui.CornerLines then
        for i = 1, 8 do setVisible(ui.CornerLines[i], false) end
    end
    ui.LastPosition = nil
    ui.StuckTime = 0
end

local function cleanESP(player)
    if not ESPCache[player] then return end
    local ui = ESPCache[player]
    if type(ui) ~= "table" then ESPCache[player] = nil; return end
    if ui.Box and ui.Box.Remove then pcall(ui.Box.Remove, ui.Box) end
    if ui.Tracer and ui.Tracer.Remove then pcall(ui.Tracer.Remove, ui.Tracer) end
    if ui.Health and ui.Health.Remove then pcall(ui.Health.Remove, ui.Health) end
    if ui.HealthBackground and ui.HealthBackground.Remove then pcall(ui.HealthBackground.Remove, ui.HealthBackground) end
    if ui.Name and ui.Name.Remove then pcall(ui.Name.Remove, ui.Name) end
    if ui.HeadDot and ui.HeadDot.Remove then pcall(ui.HeadDot.Remove, ui.HeadDot) end
    if ui.Weapon and ui.Weapon.Remove then pcall(ui.Weapon.Remove, ui.Weapon) end
    if ui.HealthText and ui.HealthText.Remove then pcall(ui.HealthText.Remove, ui.HealthText) end
    if ui.ViewAngle and ui.ViewAngle.Remove then pcall(ui.ViewAngle.Remove, ui.ViewAngle) end
    if ui.SnapLine and ui.SnapLine.Remove then pcall(ui.SnapLine.Remove, ui.SnapLine) end
    if ui.RadarDot and ui.RadarDot.Remove then pcall(ui.RadarDot.Remove, ui.RadarDot) end
    if ui.Chams and ui.Chams.Remove then pcall(ui.Chams.Remove, ui.Chams) end
    if ui.Skeleton then
        for _, line in pairs(ui.Skeleton) do if line and line.Remove then pcall(line.Remove, line) end end
    end
    if ui.Box3D then
        for _, line in pairs(ui.Box3D) do if line and line.Remove then pcall(line.Remove, line) end end
    end
    if ui.CornerLines then
        for i = 1, 8 do if ui.CornerLines[i] and ui.CornerLines[i].Remove then pcall(ui.CornerLines[i].Remove, ui.CornerLines[i]) end end
    end
    ESPCache[player] = nil
end

local function createESP(player)
    if player == LocalPlayer then return end
    if ESPCache[player] then return end
    task.spawn(function()
        local function safeDrawing(type)
            local success, obj = pcall(Drawing.new, type)
            return success and obj or nil
        end
        local box = safeDrawing("Square")
        local tracer = safeDrawing("Line")
        local health = safeDrawing("Line")
        local healthBackground = safeDrawing("Line")
        local nameObj = safeDrawing("Text")
        local headDot = safeDrawing("Circle")
        local weapon = safeDrawing("Text")
        local healthText = safeDrawing("Text")
        local viewAngle = safeDrawing("Line")
        local snapLine = safeDrawing("Line")
        local radarDot = safeDrawing("Circle")
        if box then box.Thickness = Settings.Visuals.BoxThickness; box.Filled = false; box.Visible = false end
        if tracer then tracer.Thickness = Settings.Visuals.TracerThickness; tracer.Visible = false end
        if health then health.Thickness = 3; health.Visible = false end
        if healthBackground then healthBackground.Thickness = 3; healthBackground.Color = Color3.new(0.2,0.2,0.2); healthBackground.Visible = false end
        if nameObj then nameObj.Size = 13; nameObj.Center = true; nameObj.Outline = true; nameObj.Font = 2; nameObj.Visible = false end
        if headDot then headDot.Visible = false; headDot.NumSides = 30 end
        if weapon then weapon.Size = 12; weapon.Center = true; weapon.Outline = true; weapon.Font = 2; weapon.Visible = false end
        if healthText then healthText.Size = 12; healthText.Center = true; healthText.Outline = true; healthText.Font = 2; healthText.Visible = false end
        if viewAngle then viewAngle.Thickness = 1; viewAngle.Visible = false end
        if snapLine then snapLine.Thickness = Settings.Visuals.SnapLinesThickness; snapLine.Visible = false end
        if radarDot then radarDot.Radius = 3; radarDot.NumSides = 20; radarDot.Filled = true; radarDot.Visible = false end
        local chams
        pcall(function()
            chams = Instance.new("Highlight")
            chams.FillTransparency = 0.5
            chams.OutlineTransparency = 1
            chams.FillColor = hexToColor3(Settings.Visuals.ChamsColor)
            chams.Parent = player.Character
            chams.Enabled = false
        end)
        ESPCache[player] = {
            Box = box,
            Tracer = tracer,
            Health = health,
            HealthBackground = healthBackground,
            Name = nameObj,
            HeadDot = headDot,
            Weapon = weapon,
            HealthText = healthText,
            ViewAngle = viewAngle,
            SnapLine = snapLine,
            RadarDot = radarDot,
            Chams = chams,
            Skeleton = {},
            Box3D = {},
            CornerLines = nil,
            LastPosition = nil,
            StuckTime = 0,
        }
        if player and player.CharacterRemoving then
            player.CharacterRemoving:Connect(function()
                if ESPCache[player] then hideESP(ESPCache[player]) end
            end)
        end
    end)
end

for _, p in ipairs(Players:GetPlayers()) do
    task.spawn(function()
        createESP(p)
        task.wait()
    end)
end
Players.PlayerAdded:Connect(function(p)
    task.spawn(function()
        createESP(p)
    end)
end)
Players.PlayerRemoving:Connect(cleanESP)

local function findCharacter(player)
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model.Name == player.Name then
            local hum = model:FindFirstChildOfClass("Humanoid")
            local root = model:FindFirstChild("HumanoidRootPart")
            if hum and root then return model, hum, root end
        end
    end
    return nil
end

local function getBox(character)
    local cf, size = character:GetBoundingBox()
    local top = cf.Position + Vector3.new(0, size.Y/2, 0)
    local bottom = cf.Position - Vector3.new(0, size.Y/2, 0)
    local topPos, vis1 = Camera:WorldToViewportPoint(top)
    local bottomPos, vis2 = Camera:WorldToViewportPoint(bottom)
    if not vis1 or not vis2 then return nil end
    local height = math.abs(topPos.Y - bottomPos.Y)
    local width = height / 2
    return Vector2.new(topPos.X - width/2, topPos.Y), width, height
end

local function draw3DBox(player, ui, character, color)
    if not Settings.Visuals.Box3D then
        if ui.Box3D then for _, line in pairs(ui.Box3D) do setVisible(line, false) end end
        return
    end
    if not ui.Box3D or #ui.Box3D == 0 then
        ui.Box3D = {}
        for i = 1, 12 do
            local line = Drawing.new("Line")
            if line then line.Thickness = 1; line.Color = color; line.Visible = false end
            ui.Box3D[i] = line
        end
    end
    for _, line in pairs(ui.Box3D) do if line then line.Color = color end end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then for _, line in pairs(ui.Box3D) do setVisible(line, false) end; return end
    local size = root.Size * 1.5
    local cf = root.CFrame
    local corners = {
        cf * CFrame.new( size.X/2,  size.Y/2,  size.Z/2),
        cf * CFrame.new(-size.X/2,  size.Y/2,  size.Z/2),
        cf * CFrame.new(-size.X/2, -size.Y/2,  size.Z/2),
        cf * CFrame.new( size.X/2, -size.Y/2,  size.Z/2),
        cf * CFrame.new( size.X/2,  size.Y/2, -size.Z/2),
        cf * CFrame.new(-size.X/2,  size.Y/2, -size.Z/2),
        cf * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2),
        cf * CFrame.new( size.X/2, -size.Y/2, -size.Z/2),
    }
    local screenCorners = {}
    local allOnScreen = true
    for i, corner in ipairs(corners) do
        local pos, vis = Camera:WorldToViewportPoint(corner.Position)
        if not vis then allOnScreen = false; break end
        screenCorners[i] = Vector2.new(pos.X, pos.Y)
    end
    if not allOnScreen then
        for _, line in pairs(ui.Box3D) do setVisible(line, false) end
        return
    end
    local edges = {
        {1,2}, {2,3}, {3,4}, {4,1},
        {5,6}, {6,7}, {7,8}, {8,5},
        {1,5}, {2,6}, {3,7}, {4,8}
    }
    for i, edge in ipairs(edges) do
        local line = ui.Box3D[i]
        if line then
            line.From = screenCorners[edge[1]]
            line.To = screenCorners[edge[2]]
            line.Visible = true
        end
    end
end

local function drawSkeleton(player, ui, character, color)
    if not Settings.Visuals.Skeleton then
        if ui.Skeleton then for _, line in pairs(ui.Skeleton) do setVisible(line, false) end end
        return
    end
    local isR15 = character:FindFirstChild("UpperTorso") ~= nil
    local limbPairs
    if isR15 then
        limbPairs = {
            {"Head", "UpperTorso"},
            {"UpperTorso", "LowerTorso"},
            {"UpperTorso", "LeftUpperArm"},
            {"LeftUpperArm", "LeftLowerArm"},
            {"LeftLowerArm", "LeftHand"},
            {"UpperTorso", "RightUpperArm"},
            {"RightUpperArm", "RightLowerArm"},
            {"RightLowerArm", "RightHand"},
            {"LowerTorso", "LeftUpperLeg"},
            {"LeftUpperLeg", "LeftLowerLeg"},
            {"LeftLowerLeg", "LeftFoot"},
            {"LowerTorso", "RightUpperLeg"},
            {"RightUpperLeg", "RightLowerLeg"},
            {"RightLowerLeg", "RightFoot"},
        }
    else
        limbPairs = {
            {"Head", "Torso"},
            {"Torso", "Left Arm"},
            {"Torso", "Right Arm"},
            {"Torso", "Left Leg"},
            {"Torso", "Right Leg"},
        }
    end
    if not ui.Skeleton or #ui.Skeleton == 0 then
        ui.Skeleton = {}
        for i = 1, #limbPairs do
            local line = Drawing.new("Line")
            if line then line.Thickness = Settings.Visuals.SkeletonThickness; line.Color = color; line.Visible = false end
            ui.Skeleton[i] = line
        end
    end
    for _, line in pairs(ui.Skeleton) do if line then line.Thickness = Settings.Visuals.SkeletonThickness; line.Color = color end end
    local function getPartPos(partName)
        local part = character:FindFirstChild(partName)
        if part then
            local pos, vis = Camera:WorldToViewportPoint(part.Position)
            if vis then return Vector2.new(pos.X, pos.Y) end
        end
        return nil
    end
    for i, pair in ipairs(limbPairs) do
        local from = getPartPos(pair[1])
        local to = getPartPos(pair[2])
        local line = ui.Skeleton[i]
        if line and from and to then
            line.From = from
            line.To = to
            line.Visible = true
        elseif line then
            line.Visible = false
        end
    end
end

local function getWeaponName(character)
    local tool = character:FindFirstChildOfClass("Tool")
    if tool then return tool.Name end
    local child = character:FindFirstChild("Weapon") or character:FindFirstChild("Gun")
    if child then return child.Name end
    return ""
end

local function drawCornerBox(player, ui, pos, width, height)
    if not Settings.Visuals.CornerBox then
        if ui.CornerLines then for i = 1, 8 do setVisible(ui.CornerLines[i], false) end end
        return
    end
    if not ui.CornerLines then
        ui.CornerLines = {}
        for i = 1, 8 do
            local line = Drawing.new("Line")
            if line then
                setVisible(line, false)
                line.Thickness = Settings.Visuals.CornerBoxThickness
                line.Color = hexToColor3(Settings.Visuals.CornerBoxColor)
            end
            ui.CornerLines[i] = line
        end
    end
    local color = hexToColor3(Settings.Visuals.CornerBoxColor)
    for i = 1, 8 do
        local line = ui.CornerLines[i]
        if isDrawing(line) then
            line.Thickness = Settings.Visuals.CornerBoxThickness
            line.Color = color
        end
    end
    local tl = pos
    local tr = Vector2.new(pos.X + width, pos.Y)
    local bl = Vector2.new(pos.X, pos.Y + height)
    local br = Vector2.new(pos.X + width, pos.Y + height)
    local cornerLength = math.min(width, height) * Settings.Visuals.CornerBoxLengthFactor
    setLine(ui.CornerLines[1], tl, tl + Vector2.new(cornerLength, 0), color)
    setLine(ui.CornerLines[2], tl, tl + Vector2.new(0, cornerLength), color)
    setLine(ui.CornerLines[3], tr, tr - Vector2.new(cornerLength, 0), color)
    setLine(ui.CornerLines[4], tr, tr + Vector2.new(0, cornerLength), color)
    setLine(ui.CornerLines[5], bl, bl + Vector2.new(cornerLength, 0), color)
    setLine(ui.CornerLines[6], bl, bl - Vector2.new(0, cornerLength), color)
    setLine(ui.CornerLines[7], br, br - Vector2.new(cornerLength, 0), color)
    setLine(ui.CornerLines[8], br, br - Vector2.new(0, cornerLength), color)
end

local MAX_STUCK_TIME = 1.5
local lastHealth = {}
local targetPulse = 0

RunService.RenderStepped:Connect(function(dt)
    if Settings.Visuals.Rainbow then
        local rainbow = getRainbowColor()
        Settings.Visuals.BoxColor = "#" .. rainbow:ToHex()
        Settings.Visuals.TracerColor = "#" .. rainbow:ToHex()
        Settings.Visuals.HealthColor = "#" .. rainbow:ToHex()
        Settings.Visuals.NameColor = "#" .. rainbow:ToHex()
        Settings.Visuals.DistanceColor = "#" .. rainbow:ToHex()
        Settings.Visuals.WeaponColor = "#" .. rainbow:ToHex()
        Settings.Visuals.SkeletonColor = "#" .. rainbow:ToHex()
        Settings.Visuals.CornerBoxColor = "#" .. rainbow:ToHex()
        Settings.Visuals.HeadDotColor = "#" .. rainbow:ToHex()
        Settings.Visuals.RadarColor = "#" .. rainbow:ToHex()
        Settings.Visuals.ChamsColor = "#" .. rainbow:ToHex()
        Settings.Visuals.ViewAngleColor = "#" .. rainbow:ToHex()
        Settings.Visuals.EnemyColor = "#" .. rainbow:ToHex()
        Settings.Visuals.TeamColor = "#" .. rainbow:ToHex()
        Settings.Visuals.SnapLinesColor = "#" .. rainbow:ToHex()
        Settings.Visuals.HitEffectColor = "#" .. rainbow:ToHex()
        Settings.Aimbot.LockIndicator.Color = "#" .. rainbow:ToHex()
    end
    if not Settings.Visuals.Enabled then
        for _, ui in pairs(ESPCache) do if ui then hideESP(ui) end end
        return
    end
    if Settings.Aimbot.LockIndicator.Pulse then
        targetPulse = targetPulse + dt * 2
        if targetPulse > 1 then targetPulse = 0 end
    end
    for player, ui in pairs(ESPCache) do
        if not player or not player.Parent then cleanESP(player); continue end
        local character, humanoid, root = findCharacter(player)
        if not character or not humanoid or humanoid.Health <= 0 then
            hideESP(ui); continue
        end
        if Settings.Visuals.DamageIndicators or Settings.Visuals.Hitmarkers or Settings.Visuals.HitEffect then
            local health = humanoid.Health
            local last = lastHealth[player]
            if last and last > health then
                local damage = last - health
                if Settings.Visuals.DamageIndicators then
                    local pos, onScreen = Camera:WorldToViewportPoint(character.HumanoidRootPart.Position + Vector3.new(0,3,0))
                    if onScreen then
                        table.insert(DamageIndicators, {
                            Text = tostring(math.floor(damage)),
                            Position = Vector2.new(pos.X, pos.Y),
                            Lifetime = 1,
                            StartTime = tick(),
                        })
                    end
                end
                if Settings.Visuals.Hitmarkers then
                    table.insert(Hitmarkers, {
                        StartTime = tick(),
                        Lifetime = 0.2,
                    })
                end
                if Settings.Visuals.HitEffect then
                    local color = hexToColor3(Settings.Visuals.HitEffectColor)
                    for _, part in ipairs(character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            local originalColor = part.Color
                            part.Color = color
                            task.delay(0.1, function()
                                if part and part.Parent then
                                    part.Color = originalColor
                                end
                            end)
                        end
                    end
                end
            end
            lastHealth[player] = health
        end
        if Settings.Visuals.Chams and ui.Chams then
            ui.Chams.Enabled = true
            ui.Chams.FillColor = getPlayerColor(player)
            ui.Chams.Parent = character
        elseif ui.Chams then
            ui.Chams.Enabled = false
        end
        local pos, width, height = getBox(character)
        if not pos then
            hideESP(ui); continue
        end
        if ui.LastPosition then
            if (ui.LastPosition - pos).Magnitude < 1 then
                ui.StuckTime = ui.StuckTime + dt
            else
                ui.StuckTime = 0
            end
            if ui.StuckTime >= MAX_STUCK_TIME then
                hideESP(ui); continue
            end
        end
        ui.LastPosition = pos
        local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local dist = myPos and (myPos.Position - root.Position).Magnitude or math.huge
        if dist > Settings.Visuals.MaxDistance then
            hideESP(ui); continue
        end
        local displayDist = dist
        if Settings.Visuals.DistanceUnit == "Meters (approx)" then
            displayDist = dist * 0.28
        elseif Settings.Visuals.DistanceUnit == "Feet (approx)" then
            displayDist = dist * 0.92
        end
        local boxColor = getPlayerColor(player)
        if Settings.Aimbot.LockIndicator.Enabled and player == Settings.Aimbot.StickyTarget then
            local lockColor = hexToColor3(Settings.Aimbot.LockIndicator.Color)
            if Settings.Aimbot.LockIndicator.Pulse then
                boxColor = lockColor:Lerp(Color3.new(1,1,1), targetPulse)
            else
                boxColor = lockColor
            end
        end
        local nameColor = hexToColor3(Settings.Visuals.NameColor)
        local distanceColor = getDistanceColor(dist)
        local tracerColor = hexToColor3(Settings.Visuals.TracerColor)
        local weaponColor = hexToColor3(Settings.Visuals.WeaponColor)
        local healthColor = getHealthColor(humanoid.Health, humanoid.MaxHealth)
        if Settings.Visuals.Box then
            setBox(ui.Box, Vector2.new(width, height), pos, boxColor, Settings.Visuals.BoxThickness)
        else
            setVisible(ui.Box, false)
        end
        draw3DBox(player, ui, character, boxColor)
        if Settings.Visuals.Health then
            local hp = humanoid.Health / humanoid.MaxHealth
            local healthHeight = height * hp
            local healthPos = Settings.Visuals.HealthPosition
            if Settings.Visuals.HealthBackground and ui.HealthBackground then
                if healthPos == "Left" then
                    setLine(ui.HealthBackground, Vector2.new(pos.X - 5, pos.Y + height), Vector2.new(pos.X - 5, pos.Y), Color3.new(0.2,0.2,0.2), 3)
                elseif healthPos == "Right" then
                    setLine(ui.HealthBackground, Vector2.new(pos.X + width + 5, pos.Y + height), Vector2.new(pos.X + width + 5, pos.Y), Color3.new(0.2,0.2,0.2), 3)
                elseif healthPos == "Top" then
                    setLine(ui.HealthBackground, Vector2.new(pos.X, pos.Y - 5), Vector2.new(pos.X + width, pos.Y - 5), Color3.new(0.2,0.2,0.2), 3)
                elseif healthPos == "Bottom" then
                    setLine(ui.HealthBackground, Vector2.new(pos.X, pos.Y + height + 5), Vector2.new(pos.X + width, pos.Y + height + 5), Color3.new(0.2,0.2,0.2), 3)
                end
            end
            if healthPos == "Left" then
                setLine(ui.Health, Vector2.new(pos.X - 5, pos.Y + height), Vector2.new(pos.X - 5, pos.Y + height - healthHeight), healthColor, 3)
            elseif healthPos == "Right" then
                setLine(ui.Health, Vector2.new(pos.X + width + 5, pos.Y + height), Vector2.new(pos.X + width + 5, pos.Y + height - healthHeight), healthColor, 3)
            elseif healthPos == "Top" then
                setLine(ui.Health, Vector2.new(pos.X, pos.Y - 5), Vector2.new(pos.X + width * hp, pos.Y - 5), healthColor, 3)
            elseif healthPos == "Bottom" then
                setLine(ui.Health, Vector2.new(pos.X, pos.Y + height + 5), Vector2.new(pos.X + width * hp, pos.Y + height + 5), healthColor, 3)
            end
        else
            setVisible(ui.Health, false)
            setVisible(ui.HealthBackground, false)
        end
        if Settings.Visuals.Tracer then
            local startPos
            local origin = Settings.Visuals.TracerOrigin
            if origin == "Crosshair" then
                startPos = Camera.ViewportSize / 2
            elseif origin == "Bottom Center" then
                startPos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
            elseif origin == "Top Center" then
                startPos = Vector2.new(Camera.ViewportSize.X/2, 0)
            elseif origin == "Left Center" then
                startPos = Vector2.new(0, Camera.ViewportSize.Y/2)
            elseif origin == "Right Center" then
                startPos = Vector2.new(Camera.ViewportSize.X, Camera.ViewportSize.Y/2)
            end
            setLine(ui.Tracer, startPos, Vector2.new(pos.X + width/2, pos.Y), tracerColor, Settings.Visuals.TracerThickness)
        else
            setVisible(ui.Tracer, false)
        end
        if Settings.Visuals.Name or Settings.Visuals.Distance then
            local iconText = ""
            if Settings.Visuals.TeamIcon then
                if player == LocalPlayer then
                    iconText = " "
                elseif player.Team == LocalPlayer.Team then
                    iconText = " "
                else
                    iconText = " "
                end
            end
            local distText = ""
            if Settings.Visuals.Distance and myPos then
                local unitSymbol = Settings.Visuals.DistanceUnit == "Studs" and "s" or (Settings.Visuals.DistanceUnit == "Meters (approx)" and "m" or "ft")
                distText = " [" .. math.floor(displayDist) .. unitSymbol .. "]"
            end
            local displayText = (Settings.Visuals.Name and iconText .. player.Name .. distText) or distText
            setText(ui.Name, Vector2.new(pos.X + width/2, pos.Y - 15), nameColor, displayText)
        else
            setVisible(ui.Name, false)
        end
        if Settings.Visuals.Weapon then
            local weaponName = getWeaponName(character)
            if weaponName ~= "" then
                setText(ui.Weapon, Vector2.new(pos.X + width/2, pos.Y + height + 5), weaponColor, weaponName)
            else
                setVisible(ui.Weapon, false)
            end
        else
            setVisible(ui.Weapon, false)
        end
        if Settings.Visuals.HealthText then
            local hpPercent = math.floor((humanoid.Health / humanoid.MaxHealth) * 100)
            setText(ui.HealthText, Vector2.new(pos.X - 20, pos.Y + height/2), healthColor, tostring(hpPercent) .. "%")
        else
            setVisible(ui.HealthText, false)
        end
        drawSkeleton(player, ui, character, hexToColor3(Settings.Visuals.SkeletonColor))
        drawCornerBox(player, ui, pos, width, height)
        if Settings.Visuals.HeadDot then
            local head = character:FindFirstChild("Head")
            if head then
                local headPos, headVis = Camera:WorldToViewportPoint(head.Position)
                if headVis and headPos.Z > 0 then
                    setCircle(ui.HeadDot, Vector2.new(headPos.X, headPos.Y), Settings.Visuals.HeadDotRadius, hexToColor3(Settings.Visuals.HeadDotColor), Settings.Visuals.HeadDotFilled)
                else
                    setVisible(ui.HeadDot, false)
                end
            else
                setVisible(ui.HeadDot, false)
            end
        else
            setVisible(ui.HeadDot, false)
        end
        if Settings.Visuals.ViewAngle then
            local head = character:FindFirstChild("Head")
            if head then
                local lookVector = head.CFrame.LookVector * 5
                local endPos = head.Position + lookVector
                local startScreen, startVis = Camera:WorldToViewportPoint(head.Position)
                local endScreen, endVis = Camera:WorldToViewportPoint(endPos)
                if startVis and endVis then
                    setLine(ui.ViewAngle, Vector2.new(startScreen.X, startScreen.Y), Vector2.new(endScreen.X, endScreen.Y), hexToColor3(Settings.Visuals.ViewAngleColor), 1)
                else
                    setVisible(ui.ViewAngle, false)
                end
            else
                setVisible(ui.ViewAngle, false)
            end
        else
            setVisible(ui.ViewAngle, false)
        end
        if Settings.Visuals.SnapLines then
            local head = character:FindFirstChild("Head")
            if head then
                local headPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if not onScreen or headPos.Z <= 0 then
                    local center = Camera.ViewportSize / 2
                    local dir = (head.Position - Camera.CFrame.Position).Unit
                    local t = math.huge
                    local edgePoint
                    if math.abs(dir.X) > 1e-6 then
                        if dir.X > 0 then
                            local tx = (Camera.ViewportSize.X - center.X) / dir.X
                            if tx < t then t = tx; edgePoint = center + Vector2.new(dir.X, dir.Y) * tx end
                        else
                            local tx = -center.X / dir.X
                            if tx < t then t = tx; edgePoint = center + Vector2.new(dir.X, dir.Y) * tx end
                        end
                    end
                    if math.abs(dir.Y) > 1e-6 then
                        if dir.Y > 0 then
                            local ty = (Camera.ViewportSize.Y - center.Y) / dir.Y
                            if ty < t then t = ty; edgePoint = center + Vector2.new(dir.X, dir.Y) * ty end
                        else
                            local ty = -center.Y / dir.Y
                            if ty < t then t = ty; edgePoint = center + Vector2.new(dir.X, dir.Y) * ty end
                        end
                    end
                    if edgePoint then
                        setLine(ui.SnapLine, center, edgePoint, hexToColor3(Settings.Visuals.SnapLinesColor), Settings.Visuals.SnapLinesThickness)
                        setCircle(ui.HeadDot, edgePoint, 3, hexToColor3(Settings.Visuals.SnapLinesColor), true, 1)
                    end
                else
                    setVisible(ui.SnapLine, false)
                end
            end
        end
    end
    for i = #DamageIndicators, 1, -1 do
        local d = DamageIndicators[i]
        local alpha = 1 - (tick() - d.StartTime) / d.Lifetime
        if alpha <= 0 then
            table.remove(DamageIndicators, i)
        else
            d.Position = d.Position - Vector2.new(0, 50 * dt)
            local color = Color3.new(1, 1, 0)
            local text = Drawing.new("Text")
            if text then
                text.Position = d.Position
                text.Text = d.Text
                text.Color = color
                text.Size = 20
                text.Center = true
                text.Outline = true
                text.Visible = true
                task.delay(0.03, function() text:Remove() end)
            end
        end
    end
    for i = #Hitmarkers, 1, -1 do
        local h = Hitmarkers[i]
        local alpha = 1 - (tick() - h.StartTime) / h.Lifetime
        if alpha <= 0 then
            table.remove(Hitmarkers, i)
        else
            local center = Camera.ViewportSize / 2
            local size = 10
            local color = Color3.new(1, 1, 1)
            local line1 = Drawing.new("Line")
            local line2 = Drawing.new("Line")
            if line1 and line2 then
                line1.From = center + Vector2.new(-size, -size)
                line1.To = center + Vector2.new(size, size)
                line1.Color = color
                line1.Thickness = 2
                line1.Visible = true
                line2.From = center + Vector2.new(-size, size)
                line2.To = center + Vector2.new(size, -size)
                line2.Color = color
                line2.Thickness = 2
                line2.Visible = true
                task.delay(0.03, function()
                    line1:Remove()
                    line2:Remove()
                end)
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if Settings.Visuals.Radar and Settings.Visuals.Enabled then
        local center = Vector2.new(Camera.ViewportSize.X - 100, 100)
        local size = Settings.Visuals.RadarSize
        setCircle(RadarCircle, center, size/2, Color3.new(1,1,1), false, 1)
        RadarCircle.Visible = true
        local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if myPos then
            local look = Camera.CFrame.LookVector
            local angle = math.atan2(-look.X, -look.Z)
            for player, ui in pairs(ESPCache) do
                if player and player.Character and ui.RadarDot then
                    local root = player.Character:FindFirstChild("HumanoidRootPart")
                    if root then
                        local relPos = root.Position - myPos.Position
                        local rotatedX = relPos.X * math.cos(angle) - relPos.Z * math.sin(angle)
                        local rotatedZ = relPos.X * math.sin(angle) + relPos.Z * math.cos(angle)
                        local rotated = Vector2.new(rotatedX, rotatedZ)
                        local scale = (size/2) / 100
                        local screenPos = center + rotated * scale
                        local dir = screenPos - center
                        if dir.Magnitude > size/2 then
                            screenPos = center + dir.Unit * (size/2)
                        end
                        setCircle(ui.RadarDot, screenPos, 3, getPlayerColor(player), true)
                        ui.RadarDot.Visible = true
                    end
                end
            end
        end
    else
        setVisible(RadarCircle, false)
        for _, ui in pairs(ESPCache) do
            if ui and ui.RadarDot then
                setVisible(ui.RadarDot, false)
            end
        end
    end
end)

print("rawr.xyz did it again.")
print("rawr.xyz initlizied! have fun :3")
